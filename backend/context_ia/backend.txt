---- start of file backend/app.ts 

import 'dotenv/config'; // Cargar variables de entorno al inicio
import express from 'express';
import cors from 'cors'; // Si tu frontend está en un dominio diferente
import mainRouter from './routes';

const app = express();
const PORT = process.env.PORT || 3000;

// Middlewares
app.use(cors()); // Habilitar CORS para permitir solicitudes desde tu frontend
app.use(express.json()); // Para parsear cuerpos de solicitud JSON

// Rutas principales
app.use('/api', mainRouter); // Todas tus rutas bajo /api

// Manejo de errores (opcional, pero recomendado)
app.use((err: any, req: express.Request, res: express.Response, next: express.NextFunction) => {
  console.error(err.stack);
  res.status(500).send('Something broke!');
});

// Iniciar el servidor
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});

--- end of file app.ts

---- start of file backend/routes/index.ts 
import { Router } from 'express';
import authRoutes from './authRoutes';
import userRoutes from './userRoutes';
import courseRoutes from './courseRoutes';
import notificationRoutes from './notificationRoutes';
// Importa tus otras rutas aquí (courseRoutes, talkRoutes, etc.)

const router = Router();

router.use('/auth', authRoutes);
router.use('/users', userRoutes);
router.use('/courses', courseRoutes);
router.use('/notifications', notificationRoutes);

// router.use('/talks', talkRoutes);
export default router;
---- end of file backend/routes/index.ts 



---- start of file backend/routes/userRoutes.ts 
import { Router } from 'express';
import { authenticateToken, authorizeRoles } from '../middlewares/authMiddleware';
import { getUserProfile, getAdminData } from '../controllers/userController'; // <-- Importa las funciones del controlador

const router = Router();

// GET /api/users/profile - Obtener el perfil del usuario autenticado
// Requiere autenticación
router.get('/profile', authenticateToken, getUserProfile);

// GET /api/users/admin-data - Obtener datos sensibles de administrador
// Requiere autenticación y rol de 'admin'
router.get('/admin-data', authenticateToken, authorizeRoles(['admin']), getAdminData);

export default router;
---- end of file backend/routes/userRoutes.ts 



---- start of file backend/routes/notificationRoutes.ts 
import { Router } from 'express';
// Importa las funciones directamente
import {
 getUserNotifications,
 createNotification,
 markNotificationAsRead,
 deleteNotification
} from '../controllers/notificationController';
// Importa tu middleware de autenticación JWT
import { authenticateToken } from '../middlewares/authMiddleware'; // <-- ¡IMPORTANTE! Reemplaza con tu middleware real

const router = Router();
router.get('/', authenticateToken, getUserNotifications);

router.post('/', authenticateToken, createNotification);

router.patch('/:id/read', authenticateToken, markNotificationAsRead);
router.delete('/:id', authenticateToken, deleteNotification);

export default router;
---- end of file backend/routes/notificationRoutes.ts 


---- start of file backend/routes/courseRoutes.ts 
import { Router } from 'express';
import {
getAllCourses,
getCourseById,
createCourse,
updateCourse,
deleteCourse,
} from '../controllers/courseController';
import { authenticateToken, authorizeRoles } from '../middlewares/authMiddleware';

const router = Router();

// Rutas para Cursos
// GET /api/courses - Obtener todos los cursos
// Puede ser público o requerir autenticación, dependiendo de tu lógica de negocio
router.get('/', getAllCourses);

// GET /api/courses/:id - Obtener un curso por ID
// Puede ser público o requerir autenticación
router.get('/:id', getCourseById);

// POST /api/courses - Crear un nuevo curso
// Requiere autenticación y rol de 'admin' (o 'organizer' si lo defines)
router.post('/', authenticateToken, authorizeRoles(['admin']), createCourse);

// PUT /api/courses/:id - Actualizar un curso por ID
// Requiere autenticación y rol de 'admin'
router.put('/:id', authenticateToken, authorizeRoles(['admin']), updateCourse);

// DELETE /api/courses/:id - Eliminar un curso por ID
// Requiere autenticación y rol de 'admin'
router.delete('/:id', authenticateToken, authorizeRoles(['admin']), deleteCourse);

export default router;
---- end of file backend/routes/courseRoutes.ts 



---- start of file backend/routes/authRoutes.ts 
import { Router } from 'express';
import { register, login } from '../controllers/authController';

const router = Router();

router.post('/register', register);
router.post('/login', login);

export default router;
---- end of file backend/routes/authRoutes.ts 


---- start of file backend/controllers/authController.ts 
import { Request, Response } from 'express';
import prisma from '../config/prisma';
import { hashPassword, comparePassword } from '../utils/passwordUtils';
import jwt from 'jsonwebtoken';

// Asegúrate de que JWT_SECRET esté definido en tus variables de entorno
const JWT_SECRET = process.env.JWT_SECRET || 'super_secret_fallback_key';

export const register = async (req: Request, res: Response) => {
  const { email, password, name, lastName, role } = req.body;
  try {
    const passwordHash = await hashPassword(password);
    const user = await prisma.user.create({
      data: {
        email,
        passwordHash,
        name,
        lastName,
        role: role || 'user', // Permite definir el rol si se envía, por defecto 'user'
      },
    });
    const { passwordHash: _, ...userWithoutPassword } = user;
    res.status(201).json(userWithoutPassword);
  } catch (error: any) {
    if (error.code === 'P2002') { // Prisma error code for unique constraint violation
      return res.status(400).json({ message: 'Email already registered' });
    }
    res.status(500).json({ message: 'Error registering user', error: error.message });
  }
};

export const login = async (req: Request, res: Response) => {
  const { email, password } = req.body;
  try {
    const user = await prisma.user.findUnique({ where: { email } });
    if (!user) {
      return res.status(400).json({ message: 'Invalid credentials' });
    }

    const isPasswordValid = await comparePassword(password, user.passwordHash);
    if (!isPasswordValid) {
      return res.status(400).json({ message: 'Invalid credentials' });
    }

    const token = jwt.sign(
      { userId: user.id, email: user.email, role: user.role },
      JWT_SECRET,
      { expiresIn: '1h' } // Token expira en 1 hora
    );

    res.status(200).json({ token, user: { id: user.id, email: user.email, name: user.name, role: user.role } });
  } catch (error: any) {
    res.status(500).json({ message: 'Error logging in', error: error.message });
  }
};

---- end of file backend/controllers/authController.ts 


---- start of file backend/controllers/courseController.ts 

import { Request, Response } from 'express';
import prisma from '../config/prisma'; // Importa la instancia de PrismaClient

// 1. Obtener todos los cursos (GET /api/courses)
export const getAllCourses = async (req: Request, res: Response) => {
try {
  const courses = await prisma.course.findMany({}); // findMany sin argumentos para obtener todos
  res.status(200).json(courses);
} catch (error: any) {
  res.status(500).json({ message: 'Error fetching courses', error: error.message });
}
};

// 2. Obtener un curso por ID (GET /api/courses/:id)
export const getCourseById = async (req: Request, res: Response) => {
const { id } = req.params; // Obtiene el ID de los parámetros de la URL
try {
  const course = await prisma.course.findUnique({
    where: { id },
  });

  if (!course) {
    return res.status(404).json({ message: 'Course not found' });
  }
  res.status(200).json(course);
} catch (error: any) {
  res.status(500).json({ message: 'Error fetching course', error: error.message });
}
};

// 3. Crear un nuevo curso (POST /api/courses)
export const createCourse = async (req: Request, res: Response) => {
// Desestructura los datos del cuerpo de la solicitud
const { title, description, startDate, endDate, location, organizerId, maxParticipants } = req.body;

// Validación básica (puedes añadir más validaciones con librerías como Zod o Joi)
if (!title || !description || !startDate || !endDate || !location || !organizerId) {
  return res.status(400).json({ message: 'Missing required fields' });
}

try {
  const newCourse = await prisma.course.create({
    data: {
      title,
      description,
      startDate: new Date(startDate), // Asegúrate de que las fechas sean objetos Date
      endDate: new Date(endDate),     // Asegúrate de que las fechas sean objetos Date
      location,
      organizerId,
      maxParticipants: maxParticipants ? parseInt(maxParticipants) : undefined, // Convertir a Int si existe
    },
  });
  res.status(201).json(newCourse);
} catch (error: any) {
  res.status(500).json({ message: 'Error creating course', error: error.message });
}
};

// 4. Actualizar un curso por ID (PUT /api/courses/:id)
export const updateCourse = async (req: Request, res: Response) => {
const { id } = req.params;
const { title, description, startDate, endDate, location, organizerId, status, maxParticipants, qrCodeUrl } = req.body;

try {
  const updatedCourse = await prisma.course.update({
    where: { id },
    data: {
      title,
      description,
      startDate: startDate ? new Date(startDate) : undefined,
      endDate: endDate ? new Date(endDate) : undefined,
      location,
      organizerId,
      status,
      maxParticipants: maxParticipants ? parseInt(maxParticipants) : undefined,
      qrCodeUrl,
    },
  });
  res.status(200).json(updatedCourse);
} catch (error: any) {
  if (error.code === 'P2025') { // Prisma error code for record not found
    return res.status(404).json({ message: 'Course not found' });
  }
  res.status(500).json({ message: 'Error updating course', error: error.message });
}
};

// 5. Eliminar un curso por ID (DELETE /api/courses/:id)
export const deleteCourse = async (req: Request, res: Response) => {
const { id } = req.params;
try {
  await prisma.course.delete({
    where: { id },
  });
  res.status(204).send(); // 204 No Content para eliminación exitosa
} catch (error: any) {
  if (error.code === 'P2025') { // Prisma error code for record not found
    return res.status(404).json({ message: 'Course not found' });
  }
  res.status(500).json({ message: 'Error deleting course', error: error.message });
}
};
---- end of file backend/controllers/courseController.ts 


---- start of file backend/controllers/userController.ts 

import { Request, Response } from 'express';
import prisma from '../config/prisma'; // Importa la instancia de PrismaClient

// Extender la interfaz Request para que TypeScript reconozca req.user
// Esto es necesario porque el middleware de autenticación añade 'user' a la Request
declare global {
namespace Express {
  interface Request {
    user?: { userId: string; email: string; role: string };
  }
}
}

// 1. Obtener el perfil del usuario autenticado (GET /api/users/profile)
export const getUserProfile = async (req: Request, res: Response) => {
// req.user es añadido por el middleware authenticateToken
const userId = req.user?.userId;

if (!userId) {
  return res.status(401).json({ message: 'Unauthorized: User ID not found in token.' });
}

try {
  const user = await prisma.user.findUnique({
    where: { id: userId },
    // Selecciona solo los campos que quieres exponer públicamente
    select: {
      id: true,
      email: true,
      name: true,
      lastName: true,
      countryOfBirth: true,
      cityOfResidence: true,
      career: true,
      university: true,
      dateOfBirth: true,
      role: true,
      profilePictureUrl: true,
      createdAt: true,
      updatedAt: true,
    },
  });

  if (!user) {
    return res.status(404).json({ message: 'User not found' });
  }
  res.status(200).json(user);
} catch (error: any) {
  res.status(500).json({ message: 'Error fetching user profile', error: error.message });
}
};

// 2. Obtener datos sensibles de administrador (GET /api/users/admin-data)
export const getAdminData = (req: Request, res: Response) => {
// Este controlador solo se alcanzará si el usuario está autenticado y tiene rol 'admin'
// gracias al middleware authorizeRoles(['admin'])
res.status(200).json({ message: 'This is sensitive admin data!', user: req.user });
};

// Puedes añadir más funciones aquí, por ejemplo:
// - Actualizar perfil de usuario (PUT /api/users/profile)
// - Obtener todos los usuarios (GET /api/users) - solo para admins
// - Obtener usuario por ID (GET /api/users/:id) - solo para admins
// - Eliminar usuario (DELETE /api/users/:id) - solo para admins
---- end of file backend/controllers/userController.ts 


---- start of file backend/controllers/notificationController.ts 
import { Request, Response } from 'express';
import prisma from '../config/prisma'; // Importa la instancia de PrismaClient

/**
* Obtiene todas las notificaciones para el usuario autenticado.
* Requiere un token JWT válido.
*/
export const getUserNotifications = async (req: Request, res: Response): Promise<Response> => {
 // El userId se espera que sea inyectado en el objeto req por el middleware de autenticación JWT.
 const userId = (req as any).user?.userId; // Asume que tu middleware JWT adjunta el usuario decodificado a req.user.id

 if (!userId) {
   return res.status(401).json({ message: 'Unauthorized: User ID not found in token.' });
 }

 try {
   const notifications = await prisma.notification.findMany({
     where: { userId: userId },
     orderBy: { sentAt: 'desc' }, // Ordenar por las más recientes primero
     include: { // Opcional: Incluir relaciones si necesitas mostrar datos de curso/charla
       relatedCourse: {
         select: { id: true, title: true } // Selecciona solo los campos que necesitas
       }
     }
   });

   return res.status(200).json(notifications);
 } catch (error) {
   console.error('Error fetching user notifications:', error);
   return res.status(500).json({ message: 'Internal server error while fetching notifications.' });
 }
};

/**
* Crea una nueva notificación.
* Requiere un token JWT válido para asociar la notificación a un usuario.
* Nota: En muchos casos, las notificaciones se crean por eventos del sistema,
* no directamente por el usuario. Esta ruta es para crear una notificación
* para un usuario específico.
*/
export const createNotification = async (req: Request, res: Response): Promise<Response> => {
 const { userId, type, title, message, relatedCourseId } = req.body;

 // Validación básica de entrada
 if (!userId || !type || !title || !message) {
   return res.status(400).json({ message: 'Missing required fields: userId, type, title, and message are required.' });
 }

 // Opcional: Validar que el userId de la notificación a crear
 // coincida con el userId del token si solo un usuario puede crear
 // notificaciones para sí mismo. Si es un admin, esto no sería necesario.
 // const authenticatedUserId = (req as any).user?.id;
 // if (userId !== authenticatedUserId && !(req as any).user?.isAdmin) { // Asume que tienes un rol 'isAdmin'
 //   return res.status(403).json({ message: 'Forbidden: You can only create notifications for yourself or if you are an admin.' });
 // }

 try {
   // Verificar si el userId existe en la tabla User
   const userExists = await prisma.user.findUnique({ where: { id: userId } });
   if (!userExists) {
     return res.status(404).json({ message: `User with ID ${userId} not found.` });
   }

   // Verificar si relatedCourseId existe si se proporciona
   if (relatedCourseId) {
     const courseExists = await prisma.course.findUnique({ where: { id: relatedCourseId } });
     if (!courseExists) {
       return res.status(404).json({ message: `Course with ID ${relatedCourseId} not found.` });
     }
   }


   const newNotification = await prisma.notification.create({
     data: {
       userId,
       type,
       title,
       message,
       relatedCourseId: relatedCourseId || null // Asegura que sea null si no se proporciona
     },
   });

   return res.status(201).json(newNotification);
 } catch (error) {
   console.error('Error creating notification:', error);
   return res.status(500).json({ message: 'Internal server error while creating notification.' });
 }
};

/**
* Marca una notificación como leída.
* Requiere un token JWT válido y que la notificación pertenezca al usuario.
*/
export const markNotificationAsRead = async (req: Request, res: Response): Promise<Response> => {
 const { id } = req.params; // ID de la notificación a marcar como leída
 const userId = (req as any).user?.id;

 if (!userId) {
   return res.status(401).json({ message: 'Unauthorized: User ID not found in token.' });
 }

 try {
   const notification = await prisma.notification.findUnique({
     where: { id: id },
   });

   if (!notification) {
     return res.status(404).json({ message: 'Notification not found.' });
   }

   // Asegurarse de que el usuario solo pueda marcar sus propias notificaciones como leídas
   if (notification.userId !== userId) {
     return res.status(403).json({ message: 'Forbidden: You can only mark your own notifications as read.' });
   }

   const updatedNotification = await prisma.notification.update({
     where: { id: id },
     data: { isRead: true },
   });

   return res.status(200).json(updatedNotification);
 } catch (error) {
   console.error('Error marking notification as read:', error);
   return res.status(500).json({ message: 'Internal server error while marking notification as read.' });
 }
};

/**
* Elimina una notificación.
* Requiere un token JWT válido y que la notificación pertenezca al usuario (o sea admin).
*/
export const deleteNotification = async (req: Request, res: Response): Promise<Response> => {
 const { id } = req.params;
 const userId = (req as any).user?.id;
 // const isAdmin = (req as any).user?.isAdmin; // Si tienes roles de administrador

 if (!userId) {
   return res.status(401).json({ message: 'Unauthorized: User ID not found in token.' });
 }

 try {
   const notification = await prisma.notification.findUnique({
     where: { id: id },
   });

   if (!notification) {
     return res.status(404).json({ message: 'Notification not found.' });
   }

   // Permitir eliminar solo si es el propietario de la notificación o un administrador
   if (notification.userId !== userId /* && !isAdmin */) {
     return res.status(403).json({ message: 'Forbidden: You can only delete your own notifications.' });
   }

   await prisma.notification.delete({
     where: { id: id },
   });

   return res.status(204).send(); // 204 No Content para eliminación exitosa
 } catch (error) {
   console.error('Error deleting notification:', error);
   return res.status(500).json({ message: 'Internal server error while deleting notification.' });
 }
};

---- end of file backend/controllers/notificationController.ts 